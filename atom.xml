<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Заметки о фронтенде</title>
  <subtitle>Блог Виталия Зюзина</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://juwain.github.io/"/>
  <updated>2016-05-27T11:28:39.000Z</updated>
  <id>https://juwain.github.io/</id>
  
  <author>
    <name>Виталий Зюзин</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Инспекция и причёсывание CSS</title>
    <link href="https://juwain.github.io/2016/05/27/linting-css/"/>
    <id>https://juwain.github.io/2016/05/27/linting-css/</id>
    <published>2016-05-27T09:12:29.000Z</published>
    <updated>2016-05-27T11:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Предыстория"><a href="#Предыстория" class="headerlink" title="Предыстория"></a>Предыстория</h3><p>Однажды мы <a href="https://htmlacademy.ru/blog/62-codeguide-why-what-and-how" target="_blank" rel="external">решили</a> сделать в Академии <a href="https://htmlacademy.github.io/codeguide/" target="_blank" rel="external">кодгайд</a>. Кодгайд нам стал нужен для контроля над собственным кодом HTML/CSS и кодом учебных проектов студентов, которые у нас проходят интенсивный курс.</p>
<p>Сам по себе кодгайд — хорошая, но нестрогая штука. Команда ознакомилась с ним и взяла на вооружение: загрузили правила кодгайда в мозг, собственный и ученический код стали проверять методом «пристального взгляда».</p>
<p>У такого подхода есть очевидный минус — человеческий фактор. Можно запросто забыть или упустить что-то из правил. Чтобы контролировать собственный CSS-код, мы сделали конфигурацию для <a href="http://csscomb.com/" target="_blank" rel="external">CSSComb</a> и как-то справлялись автоматическим «причёсыванием» кода. Это конечно хорошо для производительности: написал CSS, запустил «расчёску», а она тебе сама поправит все недочёты и ошибки. Но совсем не подходит для целей обучения студентов или новичков в команде: человек будет полагаться на автоматическое «причёсывание», вместо того, чтобы самому научиться писать красивый единообразный код.</p>
<p>Поэтому я задумался об автоматизированной инспекции кода.</p>
<h3 id="Линтинг"><a href="#Линтинг" class="headerlink" title="Линтинг"></a>Линтинг</h3><p>Решений для инспекции CSS на самом деле оказалось не так много. Да и захотелось ещё проверять не только CSS, но и PostCSS, на котором у нас написан новый фронтенд.</p>
<p><a href="https://github.com/CSSLint/csslint" target="_blank" rel="external">CSSLint</a> немного устарел (последний релиз 15 августа 2013), и в нём не так много возможностей для тонкой конфигурации.</p>
<p><a href="https://github.com/brigade/scss-lint" target="_blank" rel="external">SCSS-Lint</a> подходит только для SCSS, кроме того требует Ruby, что более проблематично, чем Node.js (который уже есть в проектах).</p>
<p>А вот <a href="https://github.com/stylelint/stylelint" target="_blank" rel="external">Stylelint</a> отлично себя зарекомендовал:</p>
<ul>
<li>большие возможности тонкой настройки «из коробки»;</li>
<li>возможность кастомизации;</li>
<li>работает с PostCSS и поддерживаемыми им препроцессорными синтаксисами (CSS, SCSS, LESS…).</li>
</ul>
<p>Stylelint можно запускать из консоли, из Node.js, из таск-раннера или прямо в редакторе. Я сейчас использую его преимущественно из <a href="https://atom.io/" target="_blank" rel="external">Атома</a>.</p>
<p>Всё, что Stylelint умеет проверять «из коробки», можно условно разделить на группы:</p>
<ul>
<li>проверка форматирования кода;</li>
<li>«цензура» кода;</li>
<li>нахождение и предотвращение ошибок.</li>
</ul>
<p>Всего на момент написания статьи конфигурация Stylelint содержит около 150 правил. Все правила досконально описывать в этой статье не имеет смысла, так как они подробно разобраны в <a href="http://stylelint.io/user-guide/rules/" target="_blank" rel="external">документации</a>.</p>
<h4 id="Проверка-форматирования-кода"><a href="#Проверка-форматирования-кода" class="headerlink" title="Проверка форматирования кода"></a>Проверка форматирования кода</h4><p>Основное, что я жду от линтера — проверка соответствия кодгайду. То есть отступы, табуляция, единицы измерения, отбивка — вот это всё. Вот, к примеру, условно «правильный» код:</p>
<img src="/blog/2016/05/27/linting-css/valid-code.png" alt="Пример «правильного» кода" title="Пример «правильного» кода">
<p>Отступление от описанного в конфиге форматирования сигнализирует об ошибке. Проверяется много чего:</p>
<ul>
<li>написание цветов (<code>color-hex-case</code>, <code>color-hex-length</code>, <code>color-named</code>, <code>color-no-hex</code>);</li>
<li>написание шрифтов (<code>font-family-name-quotes</code>, <code>font-weight-notation</code>);</li>
<li>пробелы и табуляция (тут очень много правил: пробелы можно проверять до и после практически любых конструкций в CSS);</li>
<li>кавычки (<code>function-url-quotes</code>, <code>string-quotes</code>);</li>
<li>переносы в CSS-правилах и списках правил (тут тоже много правил относительно разных конструкций CSS);</li>
<li>регистр букв в селекторах, свойствах и значениях (<code>unit-case</code>, <code>value-keyword-case</code>,<code>property-case</code> и другие);</li>
<li>двоеточия (<code>selector-pseudo-element-colon-notation</code>);</li>
<li>и ещё много других моментов.</li>
</ul>
<p>Пример ошибок в коде:</p>
<img src="/blog/2016/05/27/linting-css/invalid-code.png" alt="Пример кода с неправильным форматированием" title="Пример кода с неправильным форматированием">
<p>Замечу, что Stylelint развивается быстрыми темпами, и за время написания статьи в него добавили ещё с десяток новых классных правил. Так что проверка соответствия стайлгайду — довольно детальная.</p>
<h4 id="«Цензура»-кода"><a href="#«Цензура»-кода" class="headerlink" title="«Цензура» кода"></a>«Цензура» кода</h4><p>Кроме базовой проверки стиля кода, Stylelint можно использовать для тотальной «цензуры». Есть возможность вполне безобидного запрета <code>!important</code> (<code>declaration-no-important</code>), стилизации по <code>#id</code> или имени тега (<code>selector-no-attribute</code>, <code>selector-no-id</code>). А можно ввести <del>танки</del> списки запрещённых или наоборот только разрешённых свойств (<code>property-blacklist</code>, <code>property-whitelist</code>), значений (<code>property-value-blacklist</code>, <code>property-value-whitelist</code>), CSS-функций (<code>function-blacklist</code>, <code>function-whitelist</code>), единиц измерения и даже содержимого комментариев.</p>
<p>Эта возможность хорошо подходит для формирования набора правил, по которым будет обучаться новичок. Например, в интенсивных курсах HTML Academy по вёрстке для начинающих мы запрещаем пользоваться <code>!important</code> и расставлять вендорные префиксы вручную:</p>
<img src="/blog/2016/05/27/linting-css/no-important.png" alt="Пример кода с использованием !important" title="Пример кода с использованием !important">
<img src="/blog/2016/05/27/linting-css/no-prefix.png" alt="Пример кода с вендорными префиксами" title="Пример кода с вендорными префиксами">
<p>Проверку кода можно проводить перед пушем в учебный репозиторий.</p>
<h4 id="Нахождение-и-предотвращение-ошибок"><a href="#Нахождение-и-предотвращение-ошибок" class="headerlink" title="Нахождение и предотвращение ошибок"></a>Нахождение и предотвращение ошибок</h4><p>Ну хорошо. Если всё вышеизложенное можно отнести к стилю кода, то возможности Stylelint по нахождению ошибок и потенциально «опасных» мест в ваших стилях — приятный бонус линтера.</p>
<p>Опишу несколько правил Stylelint, которые находят и предотвращают ошибки.</p>
<p>Правило <code>color-no-invalid-hex</code> находит недопустимые символы в шестнадцатеричном представлении цвета:</p>
<img src="/blog/2016/05/27/linting-css/invalid-hex.png" alt="Пример кода с неправильным значением цвета" title="Пример кода с неправильным значением цвета">
<p>Правило <code>no-duplicate-selectors</code> найдёт одинаковые селекторы:</p>
<img src="/blog/2016/05/27/linting-css/no-duplicates.png" alt="Пример кода с дубликатом селектора" title="Пример кода с дубликатом селектора">
<p>Правило <code>declaration-block-no-shorthand-property-overrides</code> предотвратит бессмысленное переопределение свойств внутри правил:</p>
<img src="/blog/2016/05/27/linting-css/no-prop-override.png" alt="Пример кода с бессмысленным переопределением свойства" title="Пример кода с бессмысленным переопределением свойства">
<p>Правило <code>no-descending-specificity</code> обнаружит бессмысленное переопределение правил более специфичными селекторами.</p>
<img src="/blog/2016/05/27/linting-css/no-descending-specificity.png" alt="Пример кода с бессмысленным переопределением правила" title="Пример кода с бессмысленным переопределением правила">
<p>Правило <code>no-indistinguishable-colors</code> предупредит о похожих цветах, заданных в CSS:</p>
<img src="/blog/2016/05/27/linting-css/no-indistinguishable-colors.png" alt="Пример кода с похожими цветами" title="Пример кода с похожими цветами">
<p>На самом деле таких правил-помощников довольно много. Проще изучить их в <a href="http://stylelint.io/user-guide/rules/" target="_blank" rel="external">документации</a>, так как быстро появляются всё новые правила.</p>
<h3 id="«Причёсывание»"><a href="#«Причёсывание»" class="headerlink" title="«Причёсывание»"></a>«Причёсывание»</h3><p>В некоторых случаях хочется или нужно «причесать» стили автоматически.</p>
<p>Как я говорил раньше, мы пользовались CSSComb для причесывания стилей. Но, к сожалению, бывало, он глючно работал с нестандартным синтаксисом вроде Sass, вовсе не работал с PostCSS и в целом приостановился в развитии.</p>
<p>Так что пришлось искать ему замену. И приятной находкой оказался <a href="https://github.com/morishitter/stylefmt" target="_blank" rel="external">stylefmt</a>, который работает с понимаемыми PostCSS синтаксисами и принимает правила конфигурации Stylelint.</p>
<p>Но не всё так чудесно, как хотелось бы. Так как stylefmt — совсем свежий проект, на момент написания статьи он поддерживает далеко не все правила Stylelint:</p>
<ul>
<li>переносы и пробелы перед и после открывающих скобок (<code>block-opening-brace-newline-after</code>, <code>block-opening-brace-newline-before</code>, <code>block-opening-brace-space-after</code>, <code>block-opening-brace-space-before</code>);</li>
<li>отступы (<code>indentation</code>);</li>
<li>пробелы до и после комбинаторов (<code>selector-combinator-space-after</code>, <code>selector-combinator-space-before</code>);</li>
<li>переносы и пробелы перед и после запятых в селекторах (<code>selector-list-comma-newline-after</code>, <code>selector-list-comma-newline-before</code>, <code>selector-list-comma-space-after</code>, <code>selector-list-comma-space-before</code>).</li>
</ul>
<p>Остальное по-прежнему придётся править руками. Или можно <a href="https://github.com/morishitter/stylefmt/issues" target="_blank" rel="external">помочь сообществу</a> и запилить недостающую функциональность.</p>
<h3 id="Сортировка-свойств-в-CSS-правилах"><a href="#Сортировка-свойств-в-CSS-правилах" class="headerlink" title="Сортировка свойств в CSS-правилах"></a>Сортировка свойств в CSS-правилах</h3><p>Чем ещё был хорош CSSComb, так это автоматическая сортировка свойств внутри CSS-правил.</p>
<p>Вообще-то Stylelint умеет проверять очерёдность свойств в правилах, но линтить это нет особого смысла, так как человеку тяжело да и не нужно запоминать точный порядок всех возможных свойств.</p>
<p>А stylefmt пока что не умеет автоматически наводить порядок в очерёдности свойств.</p>
<p>Что делать?</p>
<p>На помощь пришёл замечательный инструмент <a href="https://github.com/hudochenkov/postcss-sorting" target="_blank" rel="external">PostCSS Sorting</a>. Он умеет сортировать свойства в правилах синтаксисов, которые понимает PostCSS. Этот инструмент вдохновлён CSSComb, и у него аналогичный конфиг. Запускать его можно тоже таск-раннером или из редактора.</p>
<p>Логично предположить, что рано или поздно stylefmt и PostCSS Sorting станут каким-то образом связаны, и их можно будет использовать как один инструмент.</p>
<h3 id="Итого"><a href="#Итого" class="headerlink" title="Итого"></a>Итого</h3><p>Я составил и обновляю по мере необходимости конфигурации <a href="https://github.com/htmlacademy/codeguide/blob/master/.stylelintrc" target="_blank" rel="external">для Stylelint</a> и <a href="https://github.com/htmlacademy/codeguide/blob/master/.postcss-sorting.json" target="_blank" rel="external">для PostCSS Sorting</a>. Их можно просто использовать или переопределить.</p>
<p>Держите свой код в порядке!</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Предыстория&quot;&gt;&lt;a href=&quot;#Предыстория&quot; class=&quot;headerlink&quot; title=&quot;Предыстория&quot;&gt;&lt;/a&gt;Предыстория&lt;/h3&gt;&lt;p&gt;Однажды мы &lt;a href=&quot;https://htmlac
    
    </summary>
    
    
      <category term="workflow" scheme="https://juwain.github.io/tags/workflow/"/>
    
      <category term="CSS" scheme="https://juwain.github.io/tags/CSS/"/>
    
      <category term="linting" scheme="https://juwain.github.io/tags/linting/"/>
    
  </entry>
  
  <entry>
    <title>Баги в браузерах. Кто виноват и что делать?</title>
    <link href="https://juwain.github.io/2016/05/07/dump-talk/"/>
    <id>https://juwain.github.io/2016/05/07/dump-talk/</id>
    <published>2016-05-06T22:22:45.000Z</published>
    <updated>2016-05-06T22:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>В апреле ездил в Екатеринбург на <a href="http://dump-conf.ru/" target="_blank" rel="external">ДАМП</a>. Рассказывал про баги в браузерах. Вот и видео выступления с конференции подоспело.</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/K4cQH85bntQ" frameborder="0" allowfullscreen></iframe></div>
<p><a href="http://juwain.ru/presentation/browser-bugs/" target="_blank" rel="external">Презентация</a> прилагается.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В апреле ездил в Екатеринбург на &lt;a href=&quot;http://dump-conf.ru/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ДАМП&lt;/a&gt;. Рассказывал про баги в браузерах
    
    </summary>
    
    
      <category term="CSS" scheme="https://juwain.github.io/tags/CSS/"/>
    
      <category term="доклады" scheme="https://juwain.github.io/tags/%D0%B4%D0%BE%D0%BA%D0%BB%D0%B0%D0%B4%D1%8B/"/>
    
  </entry>
  
  <entry>
    <title>Техника помидора</title>
    <link href="https://juwain.github.io/2015/09/03/pomodoro-technique/"/>
    <id>https://juwain.github.io/2015/09/03/pomodoro-technique/</id>
    <published>2015-09-03T06:00:00.000Z</published>
    <updated>2016-05-03T17:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>На прошедшей неделе я попробовал управлять своим рабочим временем нестихийным образом.</p>
<p>Накануне в ленте упомянули про технику <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BC%D0%B8%D0%B4%D0%BE%D1%80_%28%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%29" target="_blank" rel="external">Pomodoro</a>. Я решил провести эту рабочую неделю с помидорной техникой и посмотреть, что из этого получится.</p>
<h3 id="Вкратце"><a href="#Вкратце" class="headerlink" title="Вкратце"></a>Вкратце</h3><p>Техника работает. Не отвлекаясь по мелочам всю неделю работал более эффективно. Сделал боьше, чем обычно, за то же время. Рекомендую!</p>
<h3 id="Что-ещё-за-помидоры"><a href="#Что-ещё-за-помидоры" class="headerlink" title="Что ещё за помидоры"></a>Что ещё за помидоры</h3><p>Техника несложная: рабочее время делится на небольшие спринты с короткими перерывами. Во время спринта надо выключить все уведомления и не отвлекаться на раздражители: чаты, контактик, твиттер и прочие уведомляшки.</p>
<p>Спринты идут следующим образом:</p>
<ol>
<li>25 минут работы;</li>
<li>5 минут перерыв;</li>
<li>25 минут работы;</li>
<li>5 минут перерыв;</li>
<li>25 минут работы;</li>
<li>5 минут перерыв;</li>
<li>25 минут работы;</li>
<li>15 минут перерыв.</li>
</ol>
<p>Этот цикл затем повторяется по кругу. В перерывах важно отвлечься от текущего дела, а лучше вообще встать из-за компа, походить, размяться, попить водички, подумать о чём-нибудь помимо текущей задачи.</p>
<p>Это всё теория, а …</p>
<h3 id="На-практике"><a href="#На-практике" class="headerlink" title="На практике"></a>На практике</h3><p>… получается следующим образом. В начале рабочего дня я начинал разбирать разные мелкие задачи и дела, не включая счётчик помидоров.  С прошлого дня накапливаются незавершённые мелочи, рандомные коммуникации, идеи, которые надо быстро разрешить и проверить. Этот предварительный этап у меня длился от 1 до 2 часов. Дальше разбирал задачи на сегодня из общего туду-листа.</p>
<p>Затем я включал счётчик, выключал уведомления и начинал работать уже по помидорам. До большого перерыва получалось сделать от 4 до 6 помидоров.</p>
<p>В большой перерыв я шёл на обед, который занимает около часа.</p>
<p>После обеда получалось сделать от 7 до 12 помидоров.</p>
<p>Итого примерно так:</p>
<ol>
<li>1−2 часа без помидоров, рандом, подготовка;</li>
<li>2−3 часа работы;</li>
<li>1 час большой перерыв;</li>
<li>3.5−6 часов работы.</li>
</ol>
<p>Итого, в среднем за прошедшую неделю получалось от 5 до 8 часов «чистой» работы в день. И это действительно эффективная работа, когда ты полностью погружаешься и входишь в состояние потока. Плюс 1−2 часа на предварительный рандом и подготовку.</p>
<h3 id="Инструменты"><a href="#Инструменты" class="headerlink" title="Инструменты"></a>Инструменты</h3><p>Я использовал бесплатный <a href="https://itunes.apple.com/ru/app/pomodoro-one/id907364780" target="_blank" rel="external">Pomodoro One</a> для мака. Это приложение простое и понятное, выдаёт окошко на передний план и звук, когда заканчивается или начинается следующий период. Ещё рекомендовали веб-версию <a href="http://tomato-timer.com" target="_blank" rel="external">Tomato Timer</a> и платное приложение для мака <a href="https://itunes.apple.com/us/app/tadam/id531349534" target="_blank" rel="external">Tadam</a>, но я не пробовал.</p>
<h3 id="Итог"><a href="#Итог" class="headerlink" title="Итог"></a>Итог</h3><p>Если у вас есть проблемы с решением больших и сложных, множества мелких или рутинных задач, попробуйте помидорную технику. С ней увеличивается продуктивность, а главное — после работы остаются силы на другие дела.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;На прошедшей неделе я попробовал управлять своим рабочим временем нестихийным образом.&lt;/p&gt;
&lt;p&gt;Накануне в ленте упомянули про технику &lt;a h
    
    </summary>
    
    
      <category term="управление временем" scheme="https://juwain.github.io/tags/%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B5%D0%BC/"/>
    
  </entry>
  
  <entry>
    <title>Кнопка</title>
    <link href="https://juwain.github.io/2015/07/15/design-elements-button/"/>
    <id>https://juwain.github.io/2015/07/15/design-elements-button/</id>
    <published>2015-07-15T13:54:28.000Z</published>
    <updated>2016-05-03T16:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Потихоньку реализую элементы будущего дизайна HTML Academy. Вот, к примеру, кнопка с эффектом по наведению или фокусу.</p>
<p></p><p data-height="325" data-theme-id="9939" data-slug-hash="MwXvYv" data-default-tab="result" data-user="juwain" class="codepen">See the Pen <a href="http://codepen.io/juwain/pen/MwXvYv/" target="_blank" rel="external">Эффект кнопки</a> by juwain (<a href="http://codepen.io/juwain" target="_blank" rel="external">@juwain</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Потихоньку реализую элементы будущего дизайна HTML Academy. Вот, к примеру, кнопка с эффектом по наведению или фокусу.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p data
    
    </summary>
    
    
      <category term="CSS" scheme="https://juwain.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Отступы фонового изображения</title>
    <link href="https://juwain.github.io/2015/07/14/background-offsets/"/>
    <id>https://juwain.github.io/2015/07/14/background-offsets/</id>
    <published>2015-07-14T14:00:05.000Z</published>
    <updated>2016-05-03T16:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Простой способ добавить отступы фоновому изображению: <br><code>background-position: center</code> и <code>background-size: calc(100% - Npx)</code>.</p>
<p></p><p data-height="380" data-theme-id="9939" data-slug-hash="zGawGV" data-default-tab="result" data-user="juwain" class="codepen">See the Pen <a href="http://codepen.io/juwain/pen/zGawGV/" target="_blank" rel="external">zGawGV</a> by juwain (<a href="http://codepen.io/juwain" target="_blank" rel="external">@juwain</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Простой способ добавить отступы фоновому изображению: &lt;br&gt;&lt;code&gt;background-position: center&lt;/code&gt; и &lt;code&gt;background-size: calc(100% - N
    
    </summary>
    
    
      <category term="CSS" scheme="https://juwain.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JS-ликбез. this, call, apply, bind</title>
    <link href="https://juwain.github.io/2015/07/05/js-this-call-apply-bind/"/>
    <id>https://juwain.github.io/2015/07/05/js-this-call-apply-bind/</id>
    <published>2015-07-05T20:22:48.000Z</published>
    <updated>2016-05-03T17:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>А сегодня я буду вещать про <code>this</code> и методы вызова функций.</p>
<h3 id="Тот-самый-this"><a href="#Тот-самый-this" class="headerlink" title="Тот самый this"></a>Тот самый this</h3><p>Чтобы вызвать функцию и передать в неё желаемый объект в качестве <code>this</code>, можно воспользоваться методами функций <code>call</code>, <code>apply</code> или <code>bind</code>. Рассмотрим их различия.</p>
<h3 id="Метод-call"><a href="#Метод-call" class="headerlink" title="Метод call"></a>Метод call</h3><p>В качестве аргументов метод <code>call</code> функции первым принимает объект, который станет <code>this</code> внутри функции. За ним перечисляются через запятую параметры самой функции.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> omnomnom = <span class="function"><span class="keyword">function</span>(<span class="params">param1, param2</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Любимые '</span> + <span class="keyword">this</span>.category + <span class="string">': '</span> + param1 + <span class="string">', '</span> + param2);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> favorite = &#123;</div><div class="line">  <span class="attr">category</span>: <span class="string">'фрукты'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">omnomnom.call(favorite, <span class="string">'яблоко'</span>, <span class="string">'груша'</span>);</div><div class="line"></div><div class="line"><span class="comment">// выведет «Любимые фрукты: яблоко, груша»</span></div></pre></td></tr></table></figure>
<h3 id="Метод-apply"><a href="#Метод-apply" class="headerlink" title="Метод apply"></a>Метод apply</h3><p>Метод <code>apply</code> отличается от <code>call</code> тем, что в него можно передать любое число параметров в виде одного массива. В случае, когда параметров у функции много, нет необходимости их всех перечислять через запятую, а можно просто передать одним массивом.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> omnomnom = <span class="function"><span class="keyword">function</span>(<span class="params">param1, param2, param3</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Любимые '</span> + <span class="keyword">this</span>.category + <span class="string">': '</span> + param1 + <span class="string">', '</span> +</div><div class="line">  param2 + <span class="string">', '</span> + param3);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> favorite = &#123;</div><div class="line">  <span class="attr">category</span>: <span class="string">'фрукты'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">omnomnom.apply(favorite, [<span class="string">'яблоко'</span>, <span class="string">'груша'</span>, <span class="string">'вишня'</span>]);</div><div class="line"></div><div class="line"><span class="comment">// выведет «Любимые фрукты: яблоко, груша, вишня»</span></div></pre></td></tr></table></figure>
<p>Массивом в функцию удобно как раз передавать неопределённое число параметров. И внутри функции в таком случае лучше не завязываться на конкретные названия параметров, а использовать объект <code>arguments</code> для доступа ко всем параметрам сразу.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> omnomnom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Любимые '</span> + <span class="keyword">this</span>.category + <span class="string">': '</span> +</div><div class="line">  [].slice.call(<span class="built_in">arguments</span>).join(<span class="string">', '</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> favorite = &#123;</div><div class="line">  <span class="attr">category</span>: <span class="string">'фрукты'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">omnomnom.apply(favorite, [<span class="string">'яблоко'</span>, <span class="string">'груша'</span>, <span class="string">'вишня'</span>]);</div><div class="line"></div><div class="line"><span class="comment">// выведет «Любимые фрукты: яблоко, груша, вишня»</span></div></pre></td></tr></table></figure>
<h3 id="Метод-bind"><a href="#Метод-bind" class="headerlink" title="Метод bind"></a>Метод bind</h3><p>Метод <code>bind</code> отличается тем, что не выполняет функцию сразу, как <code>call</code> и <code>apply</code>, а возвращает её. Возвращённая функция вызвается как обычно, но внутри неё уже будет заданный <code>this</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> omnomnom = <span class="function"><span class="keyword">function</span>(<span class="params">param1, param2</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Любимые '</span> + <span class="keyword">this</span>.category + <span class="string">': '</span> + param1 + <span class="string">', '</span> + param2);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> favorite = &#123;</div><div class="line">  <span class="attr">category</span>: <span class="string">'фрукты'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func = omnomnom.bind(favorite, <span class="string">'яблоко'</span>);</div><div class="line">func(<span class="string">'груша'</span>);</div><div class="line"></div><div class="line"><span class="comment">// выведет «Любимые фрукты: яблоко, груша»</span></div></pre></td></tr></table></figure>
<p>Заметьте, что остальные параметры могут передаваться списком через запятую как в метод <code>bind</code>, так и при вызове возвращенной функции.</p>
<p>Продолжение следует…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;А сегодня я буду вещать про &lt;code&gt;this&lt;/code&gt; и методы вызова функций.&lt;/p&gt;
&lt;h3 id=&quot;Тот-самый-this&quot;&gt;&lt;a href=&quot;#Тот-самый-this&quot; class=&quot;heade
    
    </summary>
    
    
      <category term="JS" scheme="https://juwain.github.io/tags/JS/"/>
    
      <category term="JS-ликбез" scheme="https://juwain.github.io/tags/JS-%D0%BB%D0%B8%D0%BA%D0%B1%D0%B5%D0%B7/"/>
    
  </entry>
  
  <entry>
    <title>JS-ликбез. Циклы и обход массивов</title>
    <link href="https://juwain.github.io/2015/06/21/js-loops-and-array-iterating/"/>
    <id>https://juwain.github.io/2015/06/21/js-loops-and-array-iterating/</id>
    <published>2015-06-21T20:45:52.000Z</published>
    <updated>2016-05-03T17:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>В этой части ликбеза речь пойдёт о циклах и обходе массивов в JS.</p>
<h3 id="Переменная-длины-массива"><a href="#Переменная-длины-массива" class="headerlink" title="Переменная длины массива"></a>Переменная длины массива</h3><p>В цикле <code>for</code>, если он используется для пробега по массиву,  лучше сохранить значение длины массива в отдельную переменную, чем брать её каждую итерацию через <code>array.length</code>.</p>
<p>Нормально:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i += <span class="number">1</span>) &#123;</div><div class="line">  <span class="comment">// array.length берётся каждую итерацию</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Но можно лучше:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i += <span class="number">1</span>) &#123;</div><div class="line">  <span class="comment">// array.length в переменной len</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Цикл-for-…-in"><a href="#Цикл-for-…-in" class="headerlink" title="Цикл for … in"></a>Цикл for … in</h3><p>Цикл <code>for … in</code> медленней, чем классический <code>for</code>. Но иногда он бывает удобнее. Так что в случае использования <code>for … in</code> для перебора свойств объекта, лучше фильтровать собственные свойства с помощью функции <code>hasOwnProperty</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> obj) &#123;</div><div class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(name)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(name + <span class="string">' собственное свойство'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(name + <span class="string">' унаследованное свойство типа toString'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="forEach-и-компания"><a href="#forEach-и-компания" class="headerlink" title="forEach и компания"></a>forEach и компания</h3><p>Выполнение работы метода <code>forEach</code> проблематично прервать. Если нужно использовать метод <code>forEach</code>, и при этом есть необходимость прервать выполнение его работы, то лучше использовать похожие на <code>forEach</code> методы <code>every</code> или <code>some</code>.</p>
<p>Метод <code>every</code> будет продолжать работу до тех пор, пока в результате итерации возвращается <code>true</code>. В случае возврата <code>false</code> работа метода прерывается. Например, следующий код будет итеративно выводить первые 5 элементов массива, а затем выполнение работы метода прервётся:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</div><div class="line"></div><div class="line">arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[i]);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (arr[i] &gt;= <span class="number">5</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// выведет 1 2 3 4 5</span></div></pre></td></tr></table></figure>
<p>Метод <code>some</code> обратен <code>every</code>. То есть он будет работать, пока в итерации возвращается <code>false</code> и прервёт работу, когда возвращется <code>true</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</div><div class="line"></div><div class="line">arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[i]);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (arr[i] &gt;= <span class="number">5</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// выведет 1 2 3 4 5</span></div></pre></td></tr></table></figure>
<p>Для обхода массивов также полезны методы <code>map</code> и <code>filter</code>.</p>
<p>Метод <code>map</code> обходит массив и возвращает в результате новый массив. На каждой итерации с текущим элементом можно совершить какие-либо действия:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> doubled = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr, doubled);</div><div class="line"><span class="comment">// выведет [1, 2, 3] [2, 4, 6]</span></div></pre></td></tr></table></figure>
<p>Метод <code>filter</code>создаёт новый массив из элементов, подходящих условию фильтрующей функции:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> filtered = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> item % <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr, filtered);</div><div class="line"><span class="comment">// выведет [1, 2, 3, 4, 5] [1, 3, 5]</span></div></pre></td></tr></table></figure>
<p>Ещё один полезный метод массива – <code>reduce</code>. Он обходит массив и на каждой итерации возвращает аккумулированное значение прошлой итерации и текущий элемент массива. Таким образом можно, к примеру, просуммировать все элементы массива (свести массив к одному числу):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> reduced = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prevValue, currentValue, index, array</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> prevValue + currentValue;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr, reduced);</div><div class="line"><span class="comment">// выведет [1, 2, 3, 4] 10</span></div></pre></td></tr></table></figure>
<h3 id="Определение-массива"><a href="#Определение-массива" class="headerlink" title="Определение массива"></a>Определение массива</h3><p>Как известно, массив — это объект. То есть:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr);</div><div class="line"><span class="comment">// выведет object</span></div></pre></td></tr></table></figure>
<p>Как достоверно определить, что перед вами массив? Вот так:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr));</div><div class="line"><span class="comment">// выведет [object Array]</span></div></pre></td></tr></table></figure>
<p>Продолжение следует…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В этой части ликбеза речь пойдёт о циклах и обходе массивов в JS.&lt;/p&gt;
&lt;h3 id=&quot;Переменная-длины-массива&quot;&gt;&lt;a href=&quot;#Переменная-длины-массив
    
    </summary>
    
    
      <category term="JS" scheme="https://juwain.github.io/tags/JS/"/>
    
      <category term="JS-ликбез" scheme="https://juwain.github.io/tags/JS-%D0%BB%D0%B8%D0%BA%D0%B1%D0%B5%D0%B7/"/>
    
  </entry>
  
  <entry>
    <title>JS-ликбез. Объекты и примитивные типы</title>
    <link href="https://juwain.github.io/2015/06/11/js-objects-and-primitive-values/"/>
    <id>https://juwain.github.io/2015/06/11/js-objects-and-primitive-values/</id>
    <published>2015-06-11T20:51:04.000Z</published>
    <updated>2016-05-03T17:38:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>В этой серии статей я собираюсь осветить те части JavaScript, которые показались мне интересными в момент изучения. Статьи будут состоять из небольших блоков с примерами.</p>
<p>Поехали!</p>
<blockquote>
<p>Хороший туториал по JS есть на MDN<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></p>
</blockquote>
<h3 id="Объекты-и-примитивные-типы"><a href="#Объекты-и-примитивные-типы" class="headerlink" title="Объекты и примитивные типы"></a>Объекты и примитивные типы</h3><p>Объекты с одинаковым содержимым не равны друг другу, а примитивные типы равны.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">text</span>: <span class="string">'text'</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">text</span>: <span class="string">'text'</span>&#125;;</div><div class="line"></div><div class="line">obj1 === obj2   <span class="comment">// false</span></div><div class="line"><span class="string">'obj'</span> === <span class="string">'obj'</span> <span class="comment">// true</span></div><div class="line">[<span class="number">1</span>] === [<span class="number">1</span>]     <span class="comment">// false</span></div><div class="line"><span class="number">1</span> === <span class="number">1</span>         <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>Объекты равны друг другу, только если ссылаются на один и тот же объект.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">text</span>: <span class="string">'text'</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line"></div><div class="line">obj1 === obj2   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="Анонимная-самовызывающаяся-функция"><a href="#Анонимная-самовызывающаяся-функция" class="headerlink" title="Анонимная самовызывающаяся функция"></a>Анонимная самовызывающаяся функция</h3><p>Позволяет не загаживать глобальную область видимости. Внутрь при вызове можно передать параметры.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> param;</div><div class="line">&#125;)(anonimousParam);</div></pre></td></tr></table></figure>
<p>Синтаксис покороче — <a href="http://stackoverflow.com/questions/5827290/javascript-function-leading-bang-syntax" target="_blank" rel="external">leading bang !</a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>)</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>Вместо «!» можно использовать другие символы.</p>
<h3 id="Параметры-функций"><a href="#Параметры-функций" class="headerlink" title="Параметры функций"></a>Параметры функций</h3><p>В функцию можно передавать сколько угодно параметров, это не вызовет ошибку,  даже если это количество параметров не предусмотрено.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a, b ,c);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>); <span class="comment">// выведет «a b c»</span></div><div class="line">log(<span class="string">'a'</span>, <span class="string">'b'</span>);                <span class="comment">// выведет «a b undefined»</span></div></pre></td></tr></table></figure>
<p>Примитивные типы в качестве параметров передаются в функцию по значению:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleVal</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  val += val;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</div><div class="line">doubleVal(number);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(number); <span class="comment">// выведет «5»</span></div></pre></td></tr></table></figure>
<p>А объектные типы — по ссылке:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleObjectNumber</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  obj.number += obj.number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">number</span>: <span class="number">5</span>&#125;;</div><div class="line">doubleObjectNumber(obj);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// выведет «Object &#123;number: 10&#125;»</span></div></pre></td></tr></table></figure>
<p>Объект <code>arguments</code> функции похож на массив, но это всё таки объект. Он не имеет никаких свойств массива, кроме свойства <code>length</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length, <span class="built_in">arguments</span>.forEach, [].forEach);</div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="string">'a'</span>, <span class="string">'list'</span>, <span class="string">'of'</span>, <span class="string">'parameters'</span>);</div><div class="line"><span class="comment">// выведет «4 undefined function forEach()»</span></div></pre></td></tr></table></figure>
<p>Объект <code>arguments</code> можно преобразовать в обычный массив с помощью метода <code>slice</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">console</span>.log(args, args.forEach);</div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="string">'a'</span>, <span class="string">'list'</span>, <span class="string">'of'</span>, <span class="string">'parameters'</span>);</div><div class="line"><span class="comment">// выведет «["a", "list", "of", "parameters"] function forEach()»</span></div></pre></td></tr></table></figure>
<p>Количество параметров функции можно узнать из свойства <code>length</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">parameter1, parameter2, parameter3</span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(test.length); <span class="comment">// выведет «3»</span></div></pre></td></tr></table></figure>
<p>Продолжение следует…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В этой серии статей я собираюсь осветить те части JavaScript, которые показались мне интересными в момент изучения. Статьи будут состоять
    
    </summary>
    
    
      <category term="JS" scheme="https://juwain.github.io/tags/JS/"/>
    
      <category term="JS-ликбез" scheme="https://juwain.github.io/tags/JS-%D0%BB%D0%B8%D0%BA%D0%B1%D0%B5%D0%B7/"/>
    
  </entry>
  
  <entry>
    <title>Скринкаст по редактору Atom</title>
    <link href="https://juwain.github.io/2015/02/03/atom-screencast/"/>
    <id>https://juwain.github.io/2015/02/03/atom-screencast/</id>
    <published>2015-02-02T21:02:18.000Z</published>
    <updated>2016-05-03T16:18:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>А вот и подоспел ознакомительный дебютный скринкаст по Atom.</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/k2wyMbpvXWc" frameborder="0" allowfullscreen></iframe></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;А вот и подоспел ознакомительный дебютный скринкаст по Atom.&lt;/p&gt;
&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//www.youtube.com/embed/k2wyMb
    
    </summary>
    
    
      <category term="atom" scheme="https://juwain.github.io/tags/atom/"/>
    
      <category term="workflow" scheme="https://juwain.github.io/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>Презентация по редактору Atom</title>
    <link href="https://juwain.github.io/2015/01/21/atom/"/>
    <id>https://juwain.github.io/2015/01/21/atom/</id>
    <published>2015-01-20T21:07:01.000Z</published>
    <updated>2016-05-06T22:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Обзорная <a href="http://juwain.ru/presentation/atom-overview/" target="_blank" rel="external">презентация</a> по редактору Atom. Скоро будет ещё и скринкаст.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Обзорная &lt;a href=&quot;http://juwain.ru/presentation/atom-overview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;презентация&lt;/a&gt; по редактору Atom. Скоро б
    
    </summary>
    
    
      <category term="atom" scheme="https://juwain.github.io/tags/atom/"/>
    
      <category term="workflow" scheme="https://juwain.github.io/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>Пути пользователя</title>
    <link href="https://juwain.github.io/2014/10/03/user-way/"/>
    <id>https://juwain.github.io/2014/10/03/user-way/</id>
    <published>2014-10-02T21:47:38.000Z</published>
    <updated>2016-05-03T17:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Человек всегда стремился к совершенству: поймать мамонта покрупнее, построить лодку прочнее, возвести просторнее дом. Это качество в нас от природы. И в стремлении достичь цель (получить выгоду, возможности или влияние) мы стараемся затратить как можно меньше собственных ресурсов.</p>
<p>Так работает наш мозг: лень выполнять бессмысленные действия, тратить силы и время, если это не принесёт плодов. Но если цель ясна, а профит от её достижения очевиден, то человек способен найти более короткий путь, научиться что-то делать эффективнее или изменить окружение, чтобы меньше потратить ресурсов и при этом больше получить.</p>
<p>В большинстве каждодневных решений мы руководствуемся паттернами поведения, которые мозг всю жизнь старательно накапливает. Паттерны формируются в основном из прямого опыта человека и нужны для того, чтобы в привычных ситуациях не обдумывать одинаковые решения каждый раз заново.</p>
<p>В любой ситуации мозг в первую очередь выдаст наименее ресурсоёмкие шаблонные решения. За примером далеко ходить не надо:</p>
<img src="/blog/2014/10/03/user-way/road1.jpg" alt="Первая дорога" title="Первая дорога">
<img src="/blog/2014/10/03/user-way/road2.jpg" alt="Вторая дорога" title="Вторая дорога">
<p>Самый удобный путь — простой и короткий. Если простое решение очевидно, становится лень прилагать лишние усилия.</p>
<p>Этот принцип можно применять при проектировании любой пользовательской системы: здания, парка, веб-приложения или чего-либо ещё.</p>
<p>Итак, пользователь появляется в новой для себя системе. У него есть определённые цели или же он исследует систему, придумывая цели на ходу. В своих решениях он руководствуется собственными паттернами поведения. И, вполне возможно, что цели человека отличаются от предположенных проектировщиком. Или же человек решает свои задачи своеобразно, не так, как планировалось.</p>
<p>Что важно сделать на этом этапе знакомства с системой? Не ругать и не обижаться на пользователя за то, что он какой-то неправильный. И не заставлять идти пользователя одним непреложным путём, только потому, что так решил автор или заказчик системы. Наоборот — нужно не препятствовать пользователям и тщательно собрать и проанализировать их поведение внутри системы. При этом важно, чтобы пользователи чувствовали себя естественно и обладали достаточной свободой в принятии решений.</p>
<p>Действия пользователей фиксируются двумя способами:</p>
<ol>
<li>Пользователи сами оставляют следы, видоизменяя систему, как в случае с тропинками, фиксируются и анализируются уже последствия этих изменений. При этом прямое наблюдение за процессом может не вестись. Наиболее распространённые действия пользователей наглядно проявляются в изменениях самой системы.</li>
<li>Наблюдается непосредственно сам процесс пользовательских действий. Все наблюдения анализируются и выявляются общие признаки, направления и цели. Этот способ больше подходит для виртуальных систем, где пользователь не всегда может непосредственно влиять на систему.</li>
</ol>
<p>В обоих случаях пользователей можно дополнительно опрашивать по результатам взаимодействия с системой, но наиболее важными всё равно являются сами их действия, а не впечатления, так как многие их склонны приукрашивать.</p>
<p>Выявленные закономерности целей и направлений («протоптанные тропинки») берутся за основу при строительстве «постоянных дорог» пользователей в системе. Увидев заасфальтированную дорожку на месте привычной тропинки, пользователь будет счастлив по ней ходить. Системой с естественной навигацией, простой и понятной для большинства, будут часто и с удовольствием пользоваться.</p>
<p>При этом даже не самый удобный путь можно сделать необычным и увлекательным, и люди будут выбирать его.</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/5jw0_3-GbMg" frameborder="0" allowfullscreen></iframe></div>
<p>Это тема для следующей статьи.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Человек всегда стремился к совершенству: поймать мамонта покрупнее, построить лодку прочнее, возвести просторнее дом. Это качество в нас 
    
    </summary>
    
    
      <category term="UX" scheme="https://juwain.github.io/tags/UX/"/>
    
  </entry>
  
</feed>
