---
title: Инспекция и причёсывание CSS
date: 2016-05-27 12:12:29
tags:
- CSS
- workflow
- linting
---

### Предыстория
Однажды мы [решили](https://htmlacademy.ru/blog/62-codeguide-why-what-and-how) сделать в Академии [кодгайд](https://htmlacademy.github.io/codeguide/). Кодгайд нам стал нужен для контроля над собственным кодом HTML/CSS и кодом учебных проектов студентов, которые у нас проходят интенсивный курс.

Сам по себе кодгайд — хорошая, но нестрогая штука. Команда ознакомилась с ним и взяла на вооружение: загрузили правила кодгайда в мозг, собственный и ученический код стали проверять методом «пристального взгляда».

У такого подхода есть очевидный минус — человеческий фактор. Можно запросто забыть или упустить что-то из правил. Чтобы контролировать собственный CSS-код, мы сделали конфигурацию для [CSSComb](http://csscomb.com/) и как-то справлялись автоматическим «причёсыванием» кода. Это конечно хорошо для производительности: написал CSS, запустил «расчёску», а она тебе сама поправит все недочёты и ошибки. Но совсем не подходит для целей обучения студентов или новичков в команде: человек будет полагаться на автоматическое «причёсывание», вместо того, чтобы самому научиться писать красивый единообразный код.

Поэтому я задумался об автоматизированной инспекции кода.

### Линтинг

Решений для инспекции CSS на самом деле оказалось не так много. Да и захотелось ещё проверять не только CSS, но и PostCSS, на котором у нас написан новый фронтенд.

[CSSLint](https://github.com/CSSLint/csslint) немного устарел (последний релиз 15 августа 2013), и в нём не так много возможностей для тонкой конфигурации.

[SCSS-Lint](https://github.com/brigade/scss-lint) подходит только для SCSS, кроме того требует Ruby, что более проблематично, чем Node.js (который уже есть в проектах).

А вот [Stylelint](https://github.com/stylelint/stylelint) отлично себя зарекомендовал:
  - большие возможности тонкой настройки «из коробки»;
  - возможность кастомизации;
  - работает с PostCSS и поддерживаемыми им препроцессорными синтаксисами (CSS, SCSS, LESS…).

Stylelint можно запускать из консоли, из Node.js, из таск-раннера или прямо в редакторе. Я сейчас использую его преимущественно из [Атома](https://atom.io/).

Всё, что Stylelint умеет проверять «из коробки», можно условно разделить на группы:
  - проверка форматирования кода;
  - «цензура» кода;
  - нахождение и предотвращение ошибок.

Всего на момент написания статьи конфигурация Stylelint содержит около 150 правил. Все правила досконально описывать в этой статье не имеет смысла, так как они подробно разобраны в [документации](http://stylelint.io/user-guide/rules/).

#### Проверка форматирования кода

Основное, что я жду от линтера — проверка соответствия кодгайду. То есть отступы, табуляция, единицы измерения, отбивка — вот это всё. Вот, к примеру, условно «правильный» код:

{% asset_img valid-code.png Пример «правильного» кода %}

Отступление от описанного в конфиге форматирования сигнализирует об ошибке. Проверяется много чего:
  - написание цветов (`color-hex-case`, `color-hex-length`, `color-named`, `color-no-hex`);
  - написание шрифтов (`font-family-name-quotes`, `font-weight-notation`);
  - пробелы и табуляция (тут очень много правил: пробелы можно проверять до и после практически любых конструкций в CSS);
  - кавычки (`function-url-quotes`, `string-quotes`);
  - переносы в CSS-правилах и списках правил (тут тоже много правил относительно разных конструкций CSS);
  - регистр букв в селекторах, свойствах и значениях (`unit-case`, `value-keyword-case`,`property-case` и другие);
  - двоеточия (`selector-pseudo-element-colon-notation`);
  - и ещё много других моментов.

Пример ошибок в коде:

{% asset_img invalid-code.png Пример кода с неправильным форматированием %}

Замечу, что Stylelint развивается быстрыми темпами, и за время написания статьи в него добавили ещё с десяток новых классных правил. Так что проверка соответствия стайлгайду — довольно детальная.

#### «Цензура» кода

Кроме базовой проверки стиля кода, Stylelint можно использовать для тотальной «цензуры». Есть возможность вполне безобидного запрета `!important` (`declaration-no-important`), стилизации по `#id` или имени тега (`selector-no-attribute`, `selector-no-id`). А можно ввести ~~танки~~ списки запрещённых или наоборот только разрешённых свойств (`property-blacklist`, `property-whitelist`), значений (`property-value-blacklist`, `property-value-whitelist`), CSS-функций (`function-blacklist`, `function-whitelist`), единиц измерения и даже содержимого комментариев.

Эта возможность хорошо подходит для формирования набора правил, по которым будет обучаться новичок. Например, в интенсивных курсах HTML Academy по вёрстке для начинающих мы запрещаем пользоваться `!important` и расставлять вендорные префиксы вручную:

{% asset_img no-important.png Пример кода с использованием !important %}

{% asset_img no-prefix.png Пример кода с вендорными префиксами %}

Проверку кода можно проводить перед пушем в учебный репозиторий.

#### Нахождение и предотвращение ошибок

Ну хорошо. Если всё вышеизложенное можно отнести к стилю кода, то возможности Stylelint по нахождению ошибок и потенциально «опасных» мест в ваших стилях — приятный бонус линтера.

Опишу несколько правил Stylelint, которые находят и предотвращают ошибки.

Правило `color-no-invalid-hex` находит недопустимые символы в шестнадцатеричном представлении цвета:

{% asset_img invalid-hex.png Пример кода с неправильным значением цвета %}

Правило `no-duplicate-selectors` найдёт одинаковые селекторы:

{% asset_img no-duplicates.png Пример кода с дубликатом селектора %}

Правило `declaration-block-no-shorthand-property-overrides` предотвратит бессмысленное переопределение свойств внутри правил:

{% asset_img no-prop-override.png Пример кода с бессмысленным переопределением свойства %}

Правило `no-descending-specificity` обнаружит бессмысленное переопределение правил более специфичными селекторами.

{% asset_img no-descending-specificity.png Пример кода с бессмысленным переопределением правила %}

Правило `no-indistinguishable-colors` предупредит о похожих цветах, заданных в CSS:

{% asset_img no-indistinguishable-colors.png Пример кода с похожими цветами %}

На самом деле таких правил-помощников довольно много. Проще изучить их в [документации](http://stylelint.io/user-guide/rules/), так как быстро появляются всё новые правила.

### «Причёсывание»

В некоторых случаях хочется или нужно «причесать» стили автоматически.

Как я говорил раньше, мы пользовались CSSComb для причесывания стилей. Но, к сожалению, бывало, он глючно работал с нестандартным синтаксисом вроде Sass, вовсе не работал с PostCSS и в целом приостановился в развитии.

Так что пришлось искать ему замену. И приятной находкой оказался [stylefmt](https://github.com/morishitter/stylefmt), который работает с понимаемыми PostCSS синтаксисами и принимает правила конфигурации Stylelint.

Но не всё так чудесно, как хотелось бы. Так как stylefmt — совсем свежий проект, на момент написания статьи он поддерживает далеко не все правила Stylelint:
  - переносы и пробелы перед и после открывающих скобок (`block-opening-brace-newline-after`, `block-opening-brace-newline-before`, `block-opening-brace-space-after`, `block-opening-brace-space-before`);
  - отступы (`indentation`);
  - пробелы до и после комбинаторов (`selector-combinator-space-after`, `selector-combinator-space-before`);
  - переносы и пробелы перед и после запятых в селекторах (`selector-list-comma-newline-after`, `selector-list-comma-newline-before`, `selector-list-comma-space-after`, `selector-list-comma-space-before`).

Остальное по-прежнему придётся править руками. Или можно [помочь сообществу](https://github.com/morishitter/stylefmt/issues) и запилить недостающую функциональность.

### Сортировка свойств в CSS-правилах

Чем ещё был хорош CSSComb, так это автоматическая сортировка свойств внутри CSS-правил.

Вообще-то Stylelint умеет проверять очерёдность свойств в правилах, но линтить это нет особого смысла, так как человеку тяжело да и не нужно запоминать точный порядок всех возможных свойств.

А stylefmt пока что не умеет автоматически наводить порядок в очерёдности свойств.

Что делать?

На помощь пришёл замечательный инструмент [PostCSS Sorting](https://github.com/hudochenkov/postcss-sorting). Он умеет сортировать свойства в правилах синтаксисов, которые понимает PostCSS. Этот инструмент вдохновлён CSSComb, и у него аналогичный конфиг. Запускать его можно тоже таск-раннером или из редактора.

Логично предположить, что рано или поздно stylefmt и PostCSS Sorting станут каким-то образом связаны, и их можно будет использовать как один инструмент.

### Итого

Я составил и обновляю по мере необходимости конфигурации [для Stylelint](https://github.com/htmlacademy/codeguide/blob/master/.stylelintrc) и [для PostCSS Sorting](https://github.com/htmlacademy/codeguide/blob/master/.postcss-sorting.json). Их можно просто использовать или переопределить.

Держите свой код в порядке!
